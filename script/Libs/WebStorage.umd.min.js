/*!
 * @georapbox/web-storage
 * WebStorage is a JavaScript library that improves the way you work with localStorage or sessionStorage using a simple, localStorage-like API. It allows developers to store many types of data instead of just strings.
 *
 * @version v2.1.0
 * @author George Raptis <georapbox@gmail.com>
 * @homepage https://github.com/georapbox/web-storage#readme
 * @repository https://github.com/georapbox/web-storage.git
 * @license MIT
 */
function e(e, t) {if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");}function t(e, t) {for (var r = 0; r < t.length; r++) {var n = t[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);}}function r(e, t, r) {return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;}function n(e, t) {var r = Object.keys(e);if (Object.getOwnPropertySymbols) {var n = Object.getOwnPropertySymbols(e);t && (n = n.filter(function (t) {return Object.getOwnPropertyDescriptor(e, t).enumerable;})), r.push.apply(r, n);}return r;}function o(e) {for (var t = 1; t < arguments.length; t++) {var o = null != arguments[t] ? arguments[t] : {};t % 2 ? n(Object(o), !0).forEach(function (t) {r(e, t, o[t]);}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(o)) : n(Object(o)).forEach(function (t) {Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(o, t));});}return e;}function i(e) {return String.prototype.trim ? e.trim() : e.replace(/(^\s*|\s*$)/g, "");}function a(e, t) {return 0 === e.indexOf(t) ? e.slice(t.length) : e;}function c(e) {return null != e && ("string" == typeof e || "[object String]" === Object.prototype.toString.call(e));}function u(e) {var t = Object.prototype.toString.call(e);return "[object AsyncFunction]" === t || "[object Function]" === t || "[object GeneratorFunction]" === t;}function s(e, t) {var r = e._driver;Object.keys(r).forEach(function (n) {(function (e, t) {return r = t, n = e._keyPrefix, r.substr(0, n.length) === n;var r, n;})(e, n) && t(n, r[n]);});}var f = function () {},l = { getItem: f, setItem: f, removeItem: f };function v(e) {try {var t = window[e],r = "__web-storage__test";t.setItem(r, "test"), t.getItem(r), t.removeItem(r);} catch (e) {return !1;}return !0;}function y(e) {return v(e) ? window[e] : (console && console.warn && console.warn("WebStorage failed to create sync storage; falling back to noop storage."), l);}var g = function () {function r() {var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};e(this, r);var n = { driver: "localStorage", keyPrefix: "web-storage/" };if ("localStorage" !== (t = o(o({}, n), t)).driver && "sessionStorage" !== t.driver) throw new Error('The "driver" option must be one of "localStorage" or "sessionStorage".');if (!c(t.keyPrefix)) throw new TypeError('The "keyPrefix" option must be a string.');this._storageType = t.driver, this._driver = y(t.driver), this._keyPrefix = i(t.keyPrefix);}var n, f, l;return n = r, (f = [{ key: "getItem", value: function (e) {var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function () {};if (!c(e)) throw new TypeError("Failed to execute 'getItem' on 'Storage': The first argument must be a string.");var r = null;try {var n = this._driver.getItem(this._keyPrefix + e),o = JSON.parse(n);r = o;} catch (e) {t(e);}return r;} }, { key: "setItem", value: function (e, t) {var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function () {};if (!c(e)) throw new TypeError("Failed to execute 'setItem' on 'Storage': The first argument must be a string.");e = this._keyPrefix + e, t = null == t || u(t) ? null : t;try {this._driver.setItem(e, JSON.stringify(t));} catch (e) {r(e);}} }, { key: "removeItem", value: function (e) {var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function () {};if (!c(e)) throw new TypeError("Failed to execute 'removeItem' on 'Storage': The first argument must be a string.");try {this._driver.removeItem(this._keyPrefix + e);} catch (e) {t(e);}} }, { key: "clear", value: function () {var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {};try {s(this, this._driver.removeItem.bind(this._driver));} catch (t) {e(t);}} }, { key: "keys", value: function () {var e = this,t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {},r = [];try {return s(this, function (t) {return r.push(a(t, e._keyPrefix));}), r;} catch (e) {t(e);}} }, { key: "length", value: function () {var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {};try {return this.keys().length;} catch (t) {e(t);}} }, { key: "iterate", value: function (e) {var t = this,r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function () {};if (!u(e)) throw new TypeError("Failed to iterate on 'Storage': 'iteratorCallback' must be a function.");try {s(this, function (r, n) {var o = a(r, t._keyPrefix),i = JSON.parse(n);e.call(t, i, o);});} catch (e) {r(e);}} }]) && t(n.prototype, f), l && t(n, l), r;}();g.isAvailable = function (e) {return v(e);}, g.createInstance = function (e) {return new g(e);};export default g;